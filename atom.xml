<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[IceKe Blog]]></title>
  <subtitle><![CDATA[Stay simple, stay naive]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://kzx1025.github.io/"/>
  <updated>2016-12-08T13:57:23.000Z</updated>
  <id>http://kzx1025.github.io/</id>
  
  <author>
    <name><![CDATA[IceKe]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[关于伪工作]]></title>
    <link href="http://kzx1025.github.io/2016/12/08/fake-work/"/>
    <id>http://kzx1025.github.io/2016/12/08/fake-work/</id>
    <published>2016-12-07T16:00:00.000Z</published>
    <updated>2016-12-08T13:57:23.000Z</updated>
    <content type="html"><![CDATA[<p>记得之前的某个时间点听到一个本科的小伙伴在朋友圈发表了关于伪工作的看法。当时他大概意在抨击一些产品经理，大致意思是某些产品觉得自己好像为用户考虑了很多，做了很多，其实说真的还不如什么都不干。我对产品经理是不熟悉的，就在之前实习过的那半年里，也只是跟运维打交道，有趣的是一般产品经理会主动找程序员沟通或者变更需求，那些时间好像我跑得比运维更勤，几次我都认为某些需求定的不太合理，不过幸运的是运维大部分都采纳了。不过根据网络上的舆论情况看，很多猿都会被需求和业务逼得苦不堪言，我也是在实习那段时间领悟到这点，不能太贴近业务层面，因为业务的更迭会让一个猿写不到新的东西，学不到新的知识和技巧，当你做一件事长期不用动脑子，那这件事通常会让人身心俱疲甚至会让你处于危险的境地，源于它的重复性或者说是机械性。但是猿刚进门槛时，都或多或少接触到业务，如果你厌倦这些，就必须的得加速自己的技术成长，学会徒手造轮子，就我个人来言，我正在往这方面努力，研究生阶段也给了我更多的时间去了解和学习一个系统内部的子模块是如何实现，算是众多读研弊病中的较明显的优势。</p>
<p>至于伪工作，就是明明做的是毫无意义或者毫无价值的事情却觉得自己努力工作了一天，甚至会觉得内心非常充实。这对个人的心理上来说，不算缺点，因为至少这种感觉是让你内心舒适的。但在个人技能成长上来说，它是糟糕的(我希望在此刻加上川普的ok手势辅助加上一些强烈的情感)，可以说甚至是比打了长时间游戏，看了很多剧更糟糕，因为后者不光能放松娱乐，而且或多或少会有人负罪感能够更好的投入有价值的工作，而伪工作会让你一直处于精神麻痹的状态以为自己在认真工作，并且这种状态会让你无法自拔，让你上瘾，让你在日日夜夜中靠着这些伪工作荒唐的总结自己，最终你什么也没干成，或者什么成就都不会眷顾你。除非你运气足够好。</p>
<p>雷军是我很佩服的一个人，他说过“你不要用战术上的勤奋,掩盖战略上的懒惰”。这句话说得简直极对，我们在说人懒惰，说得是什么懒惰。其实大部分社会人在肉体上并不懒惰，甚至是极度勤奋，我曾不止一次表示过我觉得汉族算是全球中最温顺勤奋的民族，这种普适性我觉得不算荒唐。更多人是在精神上懒惰，懒于改变，懒于接收新的事物，新的知识，新的土地，仅仅操守这那一亩三分地辛勤地耕作。九十年代香港导演算得上风生水起，新世纪初港片没落，大陆市场崛起，很多导演捧着他们那块旧土地继续汲取着快要枯竭的养分，而乐于改变，具有战略眼光的导演早已瞄准这个市场，大力与大陆的演员，电影公司合作，比如我的偶像周星驰，活脱脱的求新的人，曾不止一次表示过，拍电影一定要拍新的东西，结果就是他自导自演以来，没有一部电影题材是相似的。</p>
<p>伪工作的始作俑者便是人性中的精神惰性，这种惰性使人丧失战略甚至是计划，使人迷恋于忙碌，使人透支娱乐和休闲的时间。有趣的是，这种惰性一定意义上正是在把人往一刻也不停歇的机器人方向引导。机器人没有思想，没有自己的见解，他只需要按照命令，按照流程走，伪工作就是这样。人大多时候需要做到逆人性，人性要你做什么，你就要反问他些什么。我不想把这些话说得太说教，因为我没有权利教导人们，一个很大的原因是我本人就时常受到伪工作的荼毒，用这种严重的词汇不是说我受到了多大的损害，毕竟伪工作这东西就是自己造成的，而是说明一切伪的事物都是有毒的，而且有的毒素很强。我始终告诫自己要身处于真实的境地，表达真实的想法，做真实的事情。倘若为了自欺欺人，那伪工作大可有施展的舞台。这是就像演戏，但我从来不鼓吹人生如戏，全靠演技，一切优秀的演员演戏目的各不相同，有的为了让观众欣赏到好的作品，有的享受演戏，体验不同的人生，但他们生活中都是最真实的自己，倘若非要在荧幕之外也表演一番，那他就不是演员，而是明星，是德艺双馨的艺术家。迂回这么多，那如何纠正伪，工作前询问自己为什么这样做，我这样是不是在工作，还是处于一个不真实的目的去工作，更高的一层是如何更高效地工作，有没有更聪明的办法，这是为了优雅地将工作与生活分开，否则你将把所有的时间空耗在无意义的工作学习之中，当然也有人不喜欢享受生活，他们热衷于输出生产力并乐在其中，那他们也可以通过此种改变在短暂的时间做更多的事情。说到这里，我并不是想让你的工作复杂度变得更高，而是用短时间的改革来换来更高的效率和意义，国家和公司都是这么干的。当然这仅局限于工作，生活不需要这么痛苦，生活是随性的，但再随性，也不要抛弃了真实，营造出一个“伪生活”。</p>
<p>所以，高效地、怀揣着想法学习与工作吧，这句话最主要的还是送给自己。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>记得之前的某个时间点听到一个本科的小伙伴在朋友圈发表了关于伪工作的看法。当时他大概意在抨击一些产品经理，大致意思是某些产品觉得自己好像为用户考虑了很多，做了很多，其实说真的还不如什么都不干。我对产品经理是不熟悉的，就在之前实习过的那半年里，也只是跟运维打交道，有趣的是一般产]]>
    </summary>
    
      <category term="扯淡学" scheme="http://kzx1025.github.io/tags/%E6%89%AF%E6%B7%A1%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[摸索性重写Spark的groupByKey(shuffle部分)]]></title>
    <link href="http://kzx1025.github.io/2016/12/02/groupByKey-design/"/>
    <id>http://kzx1025.github.io/2016/12/02/groupByKey-design/</id>
    <published>2016-12-02T09:20:00.000Z</published>
    <updated>2016-12-05T14:59:34.000Z</updated>
    <content type="html"><![CDATA[<pre><code>一开始实现这个特性的时候，我并不能预见其性能是否可以优化，但是不可以不尝试。
我姑且把它叫做工程师的调性. 
</code></pre><h2 id="现有的工作与策略">现有的工作与策略</h2><p>上面的前言虽说出了口，却又觉得中二，给人一种鸣人站在所有boss面前嚎着：“这就是我的忍道！”的既视感。但总觉得不得不说出来，而且是认真的那种。尝试嘛，是一个可以让人投入他所有的激情和年华在一件事上的词，此事未必带来较大的意义，但此事在经过尝试给人以信念后，会让他这一生变得更加有趣，甚至是伟大。如果有人将此作为自己做任何事的方法论，那我必然是无比佩服他的。这些话不是我刻意在技术笔记中加上一些鸡汤（对于鸡汤这种事，我并不是向大多数网友那样厌恶，我觉得能在理性的范围内给人带来正能量的东西，它绝对差不到哪里去），恰恰是我在生活中遇到一些人和事，我需要把我的所想敞开在这儿，至于为什么不单独写，那纯属是因为我懒，写不了那么大篇幅的。当然，倘若以后心血来潮，那也保不准挤出很大段文字来谈谈我的柔情似水。</p>
<p>最近Deca要在论文中加入VST拆解的思想和实现。之前包括缓存RDD这类运行中定长的数据拆解已经实现，但是shuffle buffer这一类对象中存在很多变长的成员，因为在shuffle过程中，reduceBykey尚能拆解，但比如groupByKey这个算子，它是将相同key的所有value聚合起来,也就一个key后面跟一串value，在shuffle运算过程中这个KV对的V是变长的，值是不确定的。之前我们所做的工作就是对Spark应用中的对象进行拆解，转换成基本的原生类型，获取他们的类型，这样之后就可以把它们写成字节数组的形式。</p>
<p>Spark-1.4里groupByKey在shuffle write端可以利用到堆外的内存，也就是tungsten-sort，所有的数据都会写在堆外并在堆外排序，但是shuffle-read端Spark默认还是用的HashShuffleReader,所有的聚合操作都在堆内完成，这个我们已经实现了read端的堆外版本，聚合操作运行在堆外。大致介绍下原理，这里就用到了VST拆解的原理，我们知道shuffle read端读出来的(K,C)对的基本类型，于是先实现了一个简易的map(UnsafeUnfixedWidthAggregationFlintMap),嗯名字略长。。这是一个针对系统的定制的map，也是用到了Hash原理，不过所有操作都是在堆外进行。这个map用于存储key和<strong>valueAddress</strong>，这个<strong>valueAddress</strong>是一个long型值，我们会将K对应的一组Value在堆外开辟一片疆土用于存储他们，当然每次新来value时我们会检查是否扩容，若扩容会改变这块疆土(堆外空间)的起始地址，因为涉及到内存的拷贝，所以map中的<strong>valueAddress</strong>就是这块存储区域的初始偏移地址。<strong>valueAddress</strong>指向的存储区域结构为：<br><img src="/img/map.jpg" alt=""></p>
<h2 id="让groupByKey也有mapSideCombine">让groupByKey也有mapSideCombine</h2><h3 id="策略的依据">策略的依据</h3><p>大家都知道的是reduceByKey是具有mapSideCombine特性的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Write a bunch of records to this task's output */</span></span><br><span class="line"><span class="function">override def <span class="title">write</span><span class="params">(records: Iterator[Product2[K, V]])</span>: Unit </span>= &#123;</span><br><span class="line">  val iter = <span class="keyword">if</span> (dep.aggregator.isDefined) &#123;</span><br><span class="line">    <span class="keyword">if</span> (dep.mapSideCombine) &#123;</span><br><span class="line">      dep.aggregator.get.combineValuesByKey(records, context)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      records</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    require(!dep.mapSideCombine, <span class="string">"Map-side combine without Aggregator specified!"</span>)</span><br><span class="line">    records</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (elem &lt;- iter) &#123;</span><br><span class="line">    val bucketId = dep.partitioner.getPartition(elem._1)</span><br><span class="line">    shuffle.writers(bucketId).write(elem._1, elem._2)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是HashShuffleWriter的一段代码，mapSideCombine参数会导致Map的结果调用aggregator，在写入record的时候，会判断mapSideCombine这个值，若其为真，则在shuffle的map端提前做聚合，然而这只适用于value为单个值，因为其长度和类型不变，若像groupByKey value为一组值时，这是value长度是会变化的，这对Unsafe是无法支持的。这时候有人谁说，那堆内可不可以实现mapSideCombine的groupByKey，答案是不可以，这里我看到了一段官方在代码中的注释<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> * Note: This operation may be very expensive. If you are grouping in order to perform an</span><br><span class="line"> * aggregation (such as a sum or average) over each key, using [[PairRDDFunctions.aggregateByKey]]</span><br><span class="line"> * or [[PairRDDFunctions.reduceByKey]] will provide much better performance.</span><br><span class="line"> *</span><br><span class="line"> * Note: As currently implemented, groupByKey must be able to hold all the key-value pairs <span class="keyword">for</span> any</span><br><span class="line"> * key in memory. If a key has too many values, it can result in an [[OutOfMemoryError]].</span><br><span class="line"> */</span><br><span class="line"><span class="function">def <span class="title">groupByKey</span><span class="params">(partitioner: Partitioner)</span>: RDD[<span class="params">(K, Iterable[V])</span>] </span>= self.withScope &#123;</span><br></pre></td></tr></table></figure></p>
<p>天呐，会导致OOM。<strong>但我这里还有点疑问，在map端groupByKey会引起大量相同的key的value在内存中驻留，但是这个操作在write端也会导致内存膨胀哎，略带不解。</strong><br>既然这样，为何还要实现堆外版本的，我的解释是这样的：堆外所有数据都以字节数组存储，将大大压缩对象的大小，可能达到成倍的效果，其实也就是没有对象。若堆外内存充裕的时候，实现这个特性并不会导致内存爆掉，除非几十G中的数据只有一个key这种特殊情况。我们想实现堆外groupByKey的mapSideCombine一个重要原因就是，我考虑在map端也聚合的话可以减轻read端的操作和内存压力，否则reduceByKey也不会有这个特性，当然这只是猜想，性能是否有提升还是要实验数据说话。</p>
<h3 id="具体的实现">具体的实现</h3><p>首先是record的插入：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertOrUpdateGroupRecord</span><span class="params">(</span><br><span class="line">        Object originKeyBaseObject,</span><br><span class="line">        Object keyBaseObject,</span><br><span class="line">        <span class="keyword">long</span> keyBaseOffset,</span><br><span class="line">        <span class="keyword">int</span> keyLengthInBytes,</span><br><span class="line">        <span class="keyword">int</span> partitionId,</span><br><span class="line">        Object valueBaseObject,</span><br><span class="line">        <span class="keyword">int</span> valueBaseOffset)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isContain(keyBaseObject, keyBaseOffset, keyLengthInBytes, addressLength)) &#123;</span><br><span class="line">        <span class="comment">//compact buffer数组缓冲区</span></span><br><span class="line">        <span class="comment">//key已经存在</span></span><br><span class="line">        <span class="keyword">long</span> oldValueAddress = PlatformDependent.UNSAFE.getLong(loc.getPage(), loc.getPosition() + <span class="number">4</span> + keyLengthInBytes);</span><br><span class="line">        <span class="keyword">long</span> newValueAddress = oldValueAddress;</span><br><span class="line">        <span class="keyword">switch</span>(valueType)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                newValueAddress = UnsafeBuffer.putInt(<span class="keyword">null</span>,(Long)oldValueAddress,valueType,(Integer)valueBaseObject);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                newValueAddress = UnsafeBuffer.putLong(<span class="keyword">null</span>,(Long)oldValueAddress,valueType,(Long)valueBaseObject);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                newValueAddress = UnsafeBuffer.putDouble(<span class="keyword">null</span>,(Long)oldValueAddress,valueType,(Double)valueBaseObject);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">default</span> :</span><br><span class="line">                <span class="keyword">assert</span>(valueType &lt; <span class="number">2</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//更新地址值</span></span><br><span class="line">        PlatformDependent.UNSAFE.putLong(loc.getPage(),loc.getPosition() + <span class="number">4</span> + keyLengthInBytes,newValueAddress);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br></pre></td></tr></table></figure></p>
<p>这里是key已经存在的操作，isContain类似于hashmap的contain方法，查找key是否存在，若存在key，获取到value，也就是对应key的那一组value的地址，而UnsafeBuffer就是实现那一组value存储区域的类，它负责区域的扩容与内存申请。插入记录可能会导致valueAddress的变化，所以每一次都要更新。</p>
<p>接着write方法会调用closeAndWriteOutput()这个方法，用于将排好序的KV写入磁盘文件中，用于下一个stage shuffle的读取，跟踪进去需要改写一下<strong>writeSortedFile</strong>这个方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">long</span> recordPointer = sortedRecords.packedRecordPointer.getRecordPointer();</span><br><span class="line"><span class="keyword">final</span> Object recordPage = memoryManager.getPage(recordPointer);</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">long</span> recordOffsetInPage = memoryManager.getOffsetInPage(recordPointer);</span><br><span class="line"><span class="keyword">int</span> dataRemaining = PlatformDependent.UNSAFE.getInt(recordPage, recordOffsetInPage);</span><br><span class="line"><span class="keyword">long</span> recordReadPosition = recordOffsetInPage + <span class="number">4</span>; <span class="comment">// skip over record length</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dataSize =dataRemaining;</span><br><span class="line"></span><br><span class="line"><span class="comment">//key+value/address</span></span><br><span class="line"><span class="keyword">if</span>(!needGroup) &#123;</span><br><span class="line">    <span class="keyword">while</span> (dataRemaining &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// logger.info("dataRemaining:"+dataRemaining);</span></span><br><span class="line">        <span class="comment">//assert(dataRemaining == 8l);</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> toTransfer = Math.min(DISK_WRITE_BUFFER_SIZE, dataRemaining);</span><br><span class="line">        PlatformDependent.copyMemory(</span><br><span class="line">                recordPage,</span><br><span class="line">                recordReadPosition,</span><br><span class="line">                writeBuffer,</span><br><span class="line">                PlatformDependent.BYTE_ARRAY_OFFSET,</span><br><span class="line">                toTransfer);</span><br><span class="line">        writer.write(writeBuffer, <span class="number">0</span>, toTransfer);</span><br><span class="line">        recordReadPosition += toTransfer;</span><br><span class="line">        dataRemaining -= toTransfer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>原本只是往文件中一个一个的KV写入，但现在的V指的是一组value的堆外起始地址，根据这个valueAddress才能找到真实的value值，我们现在要先写入key，接着是value的总大小，后面跟对应该key的所有value，这时候就不需要写入valueAddress的地址了，因为read端不需要这个变量。也就是加上这一段代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不用写address</span></span><br><span class="line">       dataRemaining-=<span class="number">8</span>;</span><br><span class="line">       <span class="keyword">while</span> (dataRemaining &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="comment">// logger.info("dataRemaining:"+dataRemaining);</span></span><br><span class="line">           <span class="comment">//assert(dataRemaining == 8l);</span></span><br><span class="line">           <span class="keyword">final</span> <span class="keyword">int</span> toTransfer = Math.min(DISK_WRITE_BUFFER_SIZE, dataRemaining);</span><br><span class="line">           PlatformDependent.copyMemory(</span><br><span class="line">                   recordPage,</span><br><span class="line">                   recordReadPosition,</span><br><span class="line">                   writeBuffer,</span><br><span class="line">                   PlatformDependent.BYTE_ARRAY_OFFSET,</span><br><span class="line">                   toTransfer);</span><br><span class="line">           writer.write(writeBuffer, <span class="number">0</span>, toTransfer);</span><br><span class="line">           recordReadPosition += toTransfer;</span><br><span class="line">           dataRemaining -= toTransfer;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// /**</span></span><br><span class="line">       <span class="comment">// by kzx</span></span><br><span class="line">       <span class="comment">//暂定int型key so 为4</span></span><br><span class="line">       <span class="keyword">int</span> keySize = dataSize - <span class="number">8</span>;</span><br><span class="line">       <span class="keyword">long</span> valueAddress = PlatformDependent.UNSAFE.getLong(recordPage, recordOffsetInPage + <span class="number">4</span> + keySize);</span><br><span class="line">       <span class="comment">//skip第一个size</span></span><br><span class="line">       <span class="keyword">long</span> valuePosition = valueAddress + <span class="number">4</span> ;</span><br><span class="line">       <span class="keyword">int</span> valueSize = PlatformDependent.UNSAFE.getInt(<span class="keyword">null</span>, valuePosition)-<span class="number">4</span>;<span class="comment">//减去第一个size</span></span><br><span class="line">       <span class="comment">//结构为size,realValue...</span></span><br><span class="line">       <span class="keyword">int</span> valueRemaining = valueSize;</span><br><span class="line">       <span class="keyword">while</span> (valueRemaining &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">final</span> <span class="keyword">int</span> toTransfer = Math.min(DISK_WRITE_BUFFER_SIZE, valueRemaining);</span><br><span class="line">           PlatformDependent.copyMemory(</span><br><span class="line">                   <span class="keyword">null</span>,</span><br><span class="line">                   valuePosition,</span><br><span class="line">                   writeBuffer,</span><br><span class="line">                   PlatformDependent.BYTE_ARRAY_OFFSET,</span><br><span class="line">                   toTransfer);</span><br><span class="line">           writer.write(writeBuffer, <span class="number">0</span>, toTransfer);</span><br><span class="line">           valuePosition += toTransfer;</span><br><span class="line">           valueRemaining -= toTransfer;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//记住这里写进去的valueSize没有减4</span></span><br><span class="line">       <span class="comment">//add by kzx,free memory</span></span><br><span class="line">       PlatformDependent.UNSAFE.freeMemory(valueAddress);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>切记不要忘了在写完一条记录之后要释放掉对应的堆外内存！</strong></p>
<p>然后就是read端的改写，这里花了有点时间。众所周知，Spark是惰性执行，代码中充满着各种各样的迭代器，追踪代码时都不知道哪个迭代器被调用了。最后调试发现调用路径是这样的FlintHashShuffleReader-&gt; BlockStoreShuffleFetcher-&gt; ShuffleBlockFetcherIterator.这个iterator里面的next会有一个获取Key-Value对的地方，其实也就是做对应的反序列化，我要改的地方也就在读取反序列化读取Value这儿。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Reads the object representing the value of a key-value pair. */</span></span><br><span class="line">override def readValue[T: ClassTag](): T = &#123;</span><br><span class="line"> val redundantSize = <span class="number">4</span>+<span class="number">4</span> <span class="comment">//包含了buffer中的两个size</span></span><br><span class="line">  <span class="keyword">if</span> (multiValue) &#123;</span><br><span class="line">     val valueSize = ldis.readInt()</span><br><span class="line">     <span class="keyword">if</span>(valueType == <span class="number">0</span>)&#123;</span><br><span class="line">       <span class="comment">//int</span></span><br><span class="line">       val valueNum = (valueSize-redundantSize)/<span class="number">4</span></span><br><span class="line">       val valueArray = <span class="keyword">new</span> Array[Integer](valueNum)</span><br><span class="line">       var index = <span class="number">0</span></span><br><span class="line">       <span class="keyword">while</span>(index &lt; valueNum)&#123;</span><br><span class="line">       val temp = ldis.readInt()</span><br><span class="line">       valueArray(index) = temp</span><br><span class="line">         index+=<span class="number">1</span></span><br><span class="line">       &#125;</span><br><span class="line">       valueArray.asInstanceOf[T]</span><br><span class="line">     &#125;<span class="keyword">else</span> <span class="keyword">if</span>(valueType == <span class="number">1</span>)&#123; </span><br><span class="line">     ...</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>从读单个value改写成读一组value。这里的size有点绕，起先我遇到的bug就是这个点造成的。</p>
<h3 id="测试">测试</h3><p>事情往往总是事与愿违的，也是出乎意料的。优化的效果并不好，做了与加这个特性之前的Deca比较实验：<br>write端的确快了一点，原因有二：</p>
<pre><code><span class="number">1.</span>减少了大量的<span class="built_in">key</span>的查询，因为很多相同<span class="built_in">key</span>的<span class="built_in">value</span>已经在<span class="built_in">value</span>端聚合在一起了。
<span class="number">2.</span>shuffle文件比原有的size要小，减少了网络的传输。
</code></pre><p>不过效果算得上微乎其微。最要命的是，write端由于多余的聚合操作，运行时间从2.8min提高到约4min。。平心而论，算得上失败的一次尝试了。</p>
<h2 id="后续">后续</h2><p>对于优化效果我是存有疑问的，read端不至于优化效果如此微小，这方面我暂时不想达到微小的工作这个水平。<br>//12月5日更新<br>后来我在代码中加了一些log，发现shuffle的map端内存中聚合是写文件花费时间的好几倍，这里的原因是原数据文件中相同key的value并不多，我查了一下大概就四十多个，也就是不存在hot key。所以shuffle文件的大小在加不加mapsideCombine的两种情况下相差并不大，所以当key的数量很少时，有mapSideCombine的groupByKey性能才回更有优势，insertSorter和write之间需要达到一种平衡。这个我正在做测试。<br>不过也给了一种启发，如果每个partition相同的key不多，而且每个key存在大量value时，采用mapsideCombine的groupBykey是一个不错的选择。</p>
]]></content>
    <summary type="html">
    <![CDATA[<pre><code>一开始实现这个特性的时候，我并不能预见其性能是否可以优化，但是不可以不尝试。
我姑且把它叫做工程师的调性. 
</code></pre><h2 id="现有的工作与策略">现有的工作与策略</h2><p>上面的前言虽说出了口，却又觉得中二，给人一种鸣人站在所]]>
    </summary>
    
      <category term="spark" scheme="http://kzx1025.github.io/tags/spark/"/>
    
      <category term="内存" scheme="http://kzx1025.github.io/tags/%E5%86%85%E5%AD%98/"/>
    
      <category term="序列化" scheme="http://kzx1025.github.io/tags/%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[偶遇超级僵尸进程]]></title>
    <link href="http://kzx1025.github.io/2016/11/28/super-zombie/"/>
    <id>http://kzx1025.github.io/2016/11/28/super-zombie/</id>
    <published>2016-11-28T08:50:00.000Z</published>
    <updated>2016-11-29T03:10:31.000Z</updated>
    <content type="html"><![CDATA[<pre><code>你怎么死来死去都死不了啊？
其实我差点就死了，你再给我多一点点时间，我就死定了。  <span class="comment">----喜剧之王    </span>
</code></pre><h2 id="写在前面的话">写在前面的话</h2><p>僵尸进程是经常遇到的，解决起来也比较方便。但一个偶然的机会遇到了一个父进程为1号进程的的僵尸进程，这个父进程肯定是不能随意杀死的，否则会导致严重的后果，至于什么严重的后果我也没测试过，搜了一下好像也没人细说。所以我私自地给它命名为超级僵尸进程，听起来给人一种很厉害的感觉，但又略带有一些调侃，加上上面的一句喜剧之王的台词，显得饶有趣味，好吧，岔开了，进入正题。</p>
<h2 id="Normal_Zombie">Normal Zombie</h2><h3 id="关于普通僵尸进程">关于普通僵尸进程</h3><p>首先它是如何产生的？<br>一个进程终止的方法很多，进程终止后有些信息对于父进程和内核还是很有用的，例如进程的ID号、进程的退出状态、进程运行的CPU时间等。因此进程在终止时回收所有内核分配给它的内存、关闭它打开的所有文件等等，但是还会保留以上极少的信息，以供父进程使用。父进程可以使用 wait/waitpid 等系统调用来为子进程收拾，做一些收尾工作。<br>因此，一个僵尸进程产生的过程是：父进程调用fork创建子进程后，子进程运行直至其终止，它立即从内存中移除，但<strong>进程描述符仍然保留在内存</strong>中（进程描述符占有极少的内存空间）。子进程的状态变成EXIT_ZOMBIE，并且向父进程发送SIGCHLD信号，父进程此时应该调用wait()系统调用来获取子进程的退出状态以及其它的信息。在 wait 调用之后，僵尸进程就完全从内存中移除。因此一个僵尸存在于其终止到父进程调用wait等函数这个时间的间隙，一般很快就消失，但如果编程不合理，父进程从不调用 wait 等系统调用来收集僵尸进程，那么这些进程会一直存在内存中.<br>概述来说就是两点原因：<br>1.子进程终止后向父进程发出SIGCHLD信号，父进程默认忽略了它；<br>2.父进程没有调用wait()或waitpid()函数来等待子进程的结束。<br>如何发现系统中的僵尸进程？<br>可以运行命令–&gt;<strong>ps -aux |grep -w ‘Z’</strong> (这里的-w参数表示精确匹配)</p>
<h3 id="如何杀掉普通僵尸进程">如何杀掉普通僵尸进程</h3><p>把父进程杀掉，僵尸进程会变成孤儿进程，然后过继给1号进程，而1号进程会扫描名下子进程，把 Z 状态进程回收；这时候僵尸进程已经退出了，只保留了task_struct结构体，所以发信号（-9等信号）去处理僵尸进程是无效的；</p>
<h2 id="Super_Zombie">Super Zombie</h2><h3 id="超级僵尸进程">超级僵尸进程</h3><p>通过对普通僵尸进程的分析,这样看起来好像父进程为1号进程的进程不会成为僵尸进程了，因为1号进程都会时刻扫描其子进程的状态，发现是僵尸进程就会马上去释放它的资源。<br>但是，父进程为1号进程的进程  其实也是有可能成为僵尸进程的。下面说几种情况：<br>1、进程还在被其它进程使用，退出；<br>2、进程的子线程还在执行任务，但主线程已经死掉了（可能主线程已经被杀了，systemd停止服务时会发SIGTERM信号）；<br>3、进程阻塞在某一IO请求上,这时控制权已交到内核手上,这时如果子进程被KILL掉,那么就成为父进程ID为1的僵尸进程,这个进程不会退出,会一直阻塞直到IO请求被满足。</p>
<h3 id="应对超级僵尸进程">应对超级僵尸进程</h3><p><strong>其实ppid=1的僵尸进程可以不用去管他,因为它迟早会被1号进程回收的如果有很多僵尸进程除外.</strong>并且绝大部分ppid=1的僵尸进程是暂时的：<br>1、当进程被跟踪调试完，则会自动被回收掉的；<br>2、其他子线程组的线程执行完后会自动退出，僵尸进程会被回收；<br>3、这个可能会一直挂着，如果阻塞的io永远没有到达；</p>
<p>总之，遇到少量的僵尸进程，可以不需要特意的去处理，只需要查看下根源，看看是否有潜在的bug就可以；</p>
]]></content>
    <summary type="html">
    <![CDATA[<pre><code>你怎么死来死去都死不了啊？
其实我差点就死了，你再给我多一点点时间，我就死定了。  <span class="comment">----喜剧之王    </span>
</code></pre><h2 id="写在前面的话">写在前面的话</h2><p>僵尸]]>
    </summary>
    
      <category term="linux" scheme="http://kzx1025.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[论如何调配jvm]]></title>
    <link href="http://kzx1025.github.io/2016/11/26/java-optimize/"/>
    <id>http://kzx1025.github.io/2016/11/26/java-optimize/</id>
    <published>2016-11-26T14:20:00.000Z</published>
    <updated>2016-12-02T13:57:33.000Z</updated>
    <content type="html"><![CDATA[<h2 id="一些要交代的">一些要交代的</h2><p>我的研究生主题大概可以用两个字概括，那就是搞spark。两个字可能不太严谨，因为读出来感觉就是搞斯帕克。其历经之路也可以高度总结一下: 安装配置spark -&gt; 写常用的spark应用 -&gt; 读spark源码 -&gt; 优化spark。当然优化spark，并不一定要从内核入手，有很多种方案，比如写出优雅的应用程序，调配置参数，官方还给出了一个重要的优化方案，那就是jvm优化，毕竟spark这种分布式系统很多都跑在jvm上。附上<strong><a href="https://spark.apache.org/docs/latest/tuning.html" target="_blank" rel="external">spark团队给的优化向导地址</a></strong>，里面有一部分讲的就是垃圾回收策略的选择与调控。</p>
<p>好的，让我们来快速聊下jvm^_^<br><strong>jvm的构成</strong>: jvm区域总体分两类，heap区和非heap区。heap区又分：Eden Space（伊甸园）、Survivor Space(幸存者区)、TenuredGen（老年代-养老区）。非heap区又分：Code Cache(代码缓存区)、Perm Gen（永久代）、Jvm Stack(java虚拟机栈)、Local Method Statck(本地方法栈)。<br><img src="/img/jvm.jpg" alt=""><br>曾经看过一个举例很形象，大致解释了下jvm对象的生与死。<br>假设你是一个普通的Java对象，你出生在Eden区，在Eden区有许多和你差不多的小兄弟、小姐妹，可以把Eden区当成幼儿园,在这个幼儿园里大家玩了很长时间。Eden区不能无休止地放你们在里面，所以当年纪稍大，你就要被送到学校去上学，这里假设从小学到高中都称为 Survivor区。开始的时候你在Survivor区里面划分出来的的“From”区，读到高年级了，就进了Survivor区的“To”区，中间由于学习成绩不稳定，还经常来回折腾。(这里指发生了18次young GC)直到18岁的时候，高中毕业了，该去社会上闯闯了。于是你就去了年老代，年老代里面人也很多。在年老代里,你生活了20年每次GC加一岁),最后寿终正寝，被GC回收。有一点没有提，你在年老代遇到了一个同学，他的名字叫海绵宝宝，他以及他的海绵家族永远不会死，那么他们就生活在永生代。<br>这里解释下永生代，这里面放着jvm不会去主动回收的东西，如类模版对象，方法模版对象，还有在JDK7之前的HotSpot虚拟机中，字符串常量池的字符串被存储在永久代中，因此导致了一系列的性能问题和内存溢出错误。所以在java8中移除了永生代，迎来了元空间。</p>
<h2 id="让年轻代大一点">让年轻代大一点</h2><h3 id="较大的年轻代">较大的年轻代</h3><p>由于Full GC的成本远远高于MinorGC，因此某些情况下需要尽可能将对象分配在年轻代，这在很多情况下是一个明智的选择。虽然在大部分情况下，JVM会先尝试在Eden区分配对象，但是由于空间紧张等问题，很可能不得不将部分年轻对象提前向年老代压缩。因此，在JVM参数调优时可以为应用程序分配一个合理的年轻代空间，以最大限度避免新对象直接进入年老代的情况发生。而且如果<br>JVM参数可以设置<strong>-XX:+PrintGCDetails -Xmx20M -Xms20M</strong>，这时候指jvm堆空间设置的初始内存为20M，最大也为20M。个人认为大部分情况下(比如你大概可以预估到你的程序所占内存有多大)初始堆内存和最大堆内存设置得相同较为合理一点，这样减少了jvm堆空间拓展的开销，因为如果虚拟机启动时设置使用的内存比较小，这个时候又需要初始化很多对象，虚拟机就必须重复地增加内存。分配足够大的年轻代空间，使用JVM参数<strong>-XX:+PrintGCDetails -Xmx20M -Xms20M-Xmn6M</strong>,年轻代大小为6M。</p>
<h3 id="较大较合理的幸存者区使用率">较大较合理的幸存者区使用率</h3><p>在jvm年轻代中也可以做一些配置比例上的文章，比如，设置合理的Survivor区并且提供Survivor区的使用率，可以将年轻对象保存在年轻代。一般来说,Survivor区的空间不够，或者占用量达到50%时，就会使对象进入年老代，不管它的年龄有多大.SurvivorRatio也可以优化survivor的大小,不过这对于性能的影响不是很大。SurvivorRatio是eden和survior大小比例。参数是<strong>-XX:SurvivorRatio=8</strong>。</p>
<h2 id="让大对象进入老年代">让大对象进入老年代</h2><h3 id="进入老年代你需要多大size">进入老年代你需要多大size</h3><p>我们在大部分情况下都会选择将对象分配在年轻代。但是，对于占用内存较多的大对象而言，这就会落入比较尴尬的境地。因为大对象出现在年轻代很可能扰乱年轻代GC，并破坏年轻代原有的对象结构。因为尝试在年轻代分配大对象，很可能导致空间不足，为了有足够的空间容纳大对象,JVM不得不将年轻代中的年轻对象挪到年老代。因为大对象占用空间多，所以可能需要移动大量小的年轻对象进入年老代,这对GC相当不利。基于以上原因，可以将大对象直接分配到年老代，保持年轻代对象结构的完整性，这样可以提高GC的效率。如果一个大对象同时又是一个短命的对象，假设这种情况出现很频繁，那对于GC来说会是一场灾难。原本应该用于存放永久对象的年老代，被短命的对象塞满，这也意味着对堆空间进行了洗牌，扰乱了分代内存回收的基本思路。因此，在软件开发过程中，应该尽可能避免使用短命的大对象，这是开发者应该走到的。可以使用参数-XX:PetenureSizeThreshold设置大对象直接进入年老代的阈值。<strong>当对象的大小超过这个值时，将直接在年老代分配。</strong>如果需要将1MB以上的对象直接在年老代分配，设置<strong>-XX:PetenureSizeThreshold=1000000</strong>，这里的单位是字节。</p>
<h3 id="进入老年代你需要多老">进入老年代你需要多老</h3><p>堆中的每一个对象都有自己的年龄。一般情况下，年轻对象存放在年轻代，年老对象存放在年老代。为了做到这点，虚拟机为每个对象都维护一个年龄。如果对象在Eden区，经过一次GC后依然存活，则被移动到Survivor区中，对象年龄加1。以后，如果对象每经过一次GC依然存活，则年龄再加1。当对象年龄达到阈值时，就移入年老代，成为老年对象。这个阈值的最大值可以通过参数-XX:MaxTenuringThreshold来设置，默认值是15。虽然-XX:MaxTenuringThreshold的值可能是15或者更大，但这不意味着新对象非要达到这个年龄才能进入年老代。事实上，对象实际进入年老代的年龄是虚拟机在运行时根据内存使用情况动态计算的(比如说年轻代空间不够了，需要将很多对象提前移入老年代)，这个参数指定的是阈值年龄的最大值。即，实际晋升年老代年龄等于动态计算所得的年龄与-XX:MaxTenuringThreshold中较小的那个。<br> 设置<strong>-XX:MaxTenuringThreshold=1</strong>指年轻对象经过一次GC后便进入老年代.</p>
<h2 id="其他的一些技巧">其他的一些技巧</h2><h3 id="降低GC时的STW">降低GC时的STW</h3><p>STW即stop the world，垃圾回收时会暂停所有应用线程来用于垃圾回收,首先考虑的是使用关注系统停顿的CMS回收器,因为并发清理这个阶段收集器线程和应用程序线程会并发执行,<strong>–XX:+UseConcMarkSweepGC</strong>年老代使用CMS收集器降低停顿；</p>
<h3 id="减少full_GC">减少full GC</h3><p>应尽可能将对象预留在年轻代，因为年轻代Young GC的成本远远小于年老代的Full GC。<br>–XX:ParallelGCThreads=20设置 20 个线程进行垃圾回收；<br>–XX:+UseParNewGC年轻代使用并行回收器；<br>–XX:+SurvivorRatio：设置Eden区和Survivor区的比例为 8:1。稍大的Survivor空间可以提高在年轻代回收生命周期较短的对象的可能性，如果Survivor不够大，一些短命的对象可能直接进入年老代，这对系统来说是不利的。<br>–XX:MaxTenuringThreshold设置年轻对象晋升到年老代的年龄。默认值是15次，即对象经过15次Minor GC依然存活，则进入年老代。这里设置为31，目的是让对象尽可能地保存在年轻代区域。</p>
<p>最后附上一个介绍jvm参数配置大全的文章：<a href="http://www.cnblogs.com/edwardlauxh/archive/2010/04/25/1918603.html" target="_blank" rel="external">文章地址</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="一些要交代的">一些要交代的</h2><p>我的研究生主题大概可以用两个字概括，那就是搞spark。两个字可能不太严谨，因为读出来感觉就是搞斯帕克。其历经之路也可以高度总结一下: 安装配置spark -&gt; 写常用的spark应用 -&gt; 读spark源码]]>
    </summary>
    
      <category term="java" scheme="http://kzx1025.github.io/tags/java/"/>
    
      <category term="内存" scheme="http://kzx1025.github.io/tags/%E5%86%85%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[科学配置hive+mysql+hadoop]]></title>
    <link href="http://kzx1025.github.io/2016/11/24/hive-mysql/"/>
    <id>http://kzx1025.github.io/2016/11/24/hive-mysql/</id>
    <published>2016-11-24T07:39:47.000Z</published>
    <updated>2016-11-24T13:58:52.000Z</updated>
    <content type="html"><![CDATA[<h2 id="mysql配置">mysql配置</h2><p>先前的服务器mysql有一些莫名地故障，于是准备重装。贸然重装肯定是一件愚蠢的事，首先要做的是把原有的mysql卸载干净。但如果你的mysql能正常地工作，那当我没提起这件事。卸载遵循以下步骤：</p>
<pre><code><span class="keyword">*</span>运行rpm -qa|<span class="string">grep -i mysql。 显示如下：</span>
</code></pre><p><img src="/img/3.jpg" alt=""></p>
<pre><code><span class="keyword">*</span>删掉它们，当然之前要停止mysql服务，运行rpm -e --nodeps 包名
<span class="keyword">*</span>查找之前老版本mysql的目录、并且删除老版本mysql的文件和库,运行find / -name mysql，会出现很多关于mysql的目录，删掉它们。
<span class="keyword">*</span>run <span class="string">"rm -rf /etc/my.cnf"</span>
<span class="keyword">*</span>再次查找机器是否安装mysql --&gt;rpm -qa|<span class="string">grep -i mysql</span>
</code></pre><p> 接下来安装mysql，方便起见，采用rpm的安装方式。下载mysql全家桶<a href="http://115.156.188.231/cdn.mysql.com//Downloads/MySQL-5.5/MySQL-5.5.53-1.linux2.6.x86_64.rpm-bundle.tar" target="_blank" rel="external">下载地址</a>，然后解压，安装=》sudo rpm -ivh MySQL-*。顺便转一下配置文件=》sudo cp /usr/share/mysql/my-large.cnf /etc/my.cnf。<br> 开启mysql服务=》  service mysql start。<br> 设置用户密码=》 sudo /usr/bin/mysqladmin -u root password ‘123’<br> 进入mysql=》mysql -uroot -p123<br> 创建mysql的hive用户=》 CREATE USER ‘hive’@’localhost’ IDENTIFIED BY “123”<br> 创建数据库=》create database hive;<br> 赋予权限=》 grant all on hive.<em> to hive@’%’  identified by ‘hive’; grant all on hive.</em> to hive@’localhost’  identified by ‘hive’; flush privileges;<br> 退出mysql<br>顺便可以验证下hive用户=》mysql -uhive -phive</p>
<h2 id="hadoop安装">hadoop安装</h2><p>略<br>不过注意一个问题：之前hadoop start起来没问题，也没有仔细看日志，但是运行hadoop命令总是遇到connection refused的问题，之前以为防火墙的原因。后来发现是用户bashrc的环境配置默认hadoop是另一个版本的，所以hadoop的命令工具来自另个hadoop。这个错误原因有点离谱，但还是挺难发现的。</p>
<h2 id="hive安装与配置">hive安装与配置</h2><h3 id="安装配置">安装配置</h3><p>首先下载 hive1.2.1=》 nohup wget <a href="http://mirrors.hust.edu.cn/apache/hive/stable/apache-hive-1.2.1-bin.tar.gz" target="_blank" rel="external">http://mirrors.hust.edu.cn/apache/hive/stable/apache-hive-1.2.1-bin.tar.gz</a> &amp;<br>解压 tar -zxvf ..<br>配置环境变量 .bashrc=&gt;<br>export HIVE_HOME=/home/feiwang/hive-2.0<br>export HIVE_CONF_DIR=/home/feiwang/hive-2.0/conf<br>export PATH=$PATH:$HIVE_HOME/bin<br>source .bashrc<br>修改hive配置文件，<strong>将默认文件mv成hive-site.xml，不是hive-default.xml！</strong>之前一直读取配置有问题就是这个原因。<br>主要修改以下参数：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">property</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;<span class="title">name</span>&gt;</span>javax.jdo.option.ConnectionURL <span class="tag">&lt;/<span class="title">name</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;<span class="title">value</span>&gt;</span>jdbc:mysql://localhost:3306/hive <span class="tag">&lt;/<span class="title">value</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="title">property</span>&gt;</span> </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="title">property</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;<span class="title">name</span>&gt;</span>javax.jdo.option.ConnectionDriverName <span class="tag">&lt;/<span class="title">name</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;<span class="title">value</span>&gt;</span>com.mysql.jdbc.Driver <span class="tag">&lt;/<span class="title">value</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="title">property</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;<span class="title">name</span>&gt;</span>javax.jdo.option.ConnectionPassword <span class="tag">&lt;/<span class="title">name</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;<span class="title">value</span>&gt;</span>hive <span class="tag">&lt;/<span class="title">value</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="title">property</span>&gt;</span> </span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="title">property</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;<span class="title">name</span>&gt;</span>hive.hwi.listen.port <span class="tag">&lt;/<span class="title">name</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;<span class="title">value</span>&gt;</span>9999 <span class="tag">&lt;/<span class="title">value</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;<span class="title">description</span>&gt;</span>This is the port the Hive Web Interface will listen on <span class="tag">&lt;/<span class="title">descript</span> <span class="attribute">ion</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="title">property</span>&gt;</span> </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="title">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">name</span>&gt;</span>javax.jdo.option.ConnectionUserName<span class="tag">&lt;/<span class="title">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">value</span>&gt;</span>hive<span class="tag">&lt;/<span class="title">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">description</span>&gt;</span>Username to use against metastore database<span class="tag">&lt;/<span class="title">description</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="title">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">name</span>&gt;</span>hive.metastore.uris<span class="tag">&lt;/<span class="title">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">value</span>&gt;</span>thrift://127.0.0.1:9083<span class="tag">&lt;/<span class="title">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">description</span>&gt;</span>Thrift URI for the remote metastore. Used by metastore client to connect to remote metastore.<span class="tag">&lt;/<span class="title">description</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="title">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">name</span>&gt;</span>hive.exec.scratchdir<span class="tag">&lt;/<span class="title">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">value</span>&gt;</span>/tmp/hive<span class="tag">&lt;/<span class="title">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">description</span>&gt;</span>HDFS root scratch dir for Hive jobs which gets created with write all (733) permission. For each connecting user, an HDFS scratch dir: $&#123;hive.exec.scratchdir&#125;/&amp;lt;username&amp;gt; is created, with $&#123;hive.scratch.dir.permission&#125;.<span class="tag">&lt;/<span class="title">description</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">name</span>&gt;</span>hive.exec.local.scratchdir<span class="tag">&lt;/<span class="title">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">value</span>&gt;</span>/tmp/hive/local<span class="tag">&lt;/<span class="title">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">description</span>&gt;</span>Local scratch space for Hive jobs<span class="tag">&lt;/<span class="title">description</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">name</span>&gt;</span>hive.downloaded.resources.dir<span class="tag">&lt;/<span class="title">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">value</span>&gt;</span>/tmp/hive/resources<span class="tag">&lt;/<span class="title">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">description</span>&gt;</span>Temporary local directory for added resources in the remote file system.<span class="tag">&lt;/<span class="title">description</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>下载jdbc的jar包=》wget <a href="http://115.156.188.231/cdn.mysql.com//Downloads/Connector-J/mysql-connector-java-5.1.40.tar.gz" target="_blank" rel="external">http://115.156.188.231/cdn.mysql.com//Downloads/Connector-J/mysql-connector-java-5.1.40.tar.gz</a></p>
<p>拷贝mysql-connector-java-5.1.40-bin.jar 到hive 的lib下面<br>mv mysql-connector-java-5.1.40-bin.jar /root/feiwang/hive-2.0/lib/</p>
<p>启动元数据 =》<strong>bin/hive –service metastore &amp;</strong></p>
<h3 id="验证">验证</h3><p>运行 hive命令,创建表：<br><img src="/img/4.jpg" alt=""><br>进入mysql会发现hive数据库自动生成了很多表<br><img src="/img/5.jpg" alt=""><br>进入hadoop的hdfs会发现也有两个文件夹生成了<br>Found 2 items<br><strong>drwxr-xr-x   - root supergroup          0 2016-11-24 21:43 /user/hive/warehouse/diablo</strong><br><strong>drwxr-xr-x   - root supergroup          0 2016-11-24 19:45 /user/hive/warehouse/kzx</strong></p>
<h3 id="简单介绍下hive">简单介绍下hive</h3><p>Hive是运行在Hadoop之上的数据仓库，将结构化的数据文件映射为一张数据库表，提供简单类SQL查询语言，称为HQL，并将SQL语句转换成MapReduce任务运。有利于利用SQL语言查询、分析数据，适于处理不频繁变动的数据。Hive底层可以是HBase或者HDFS存储的文件。两者都是基于Hadoop上不同的技术，相互结合使用，可处理企业中不同类型的业务，利用Hive处理非结构化离线分析统计，利用HBase处理在线查询。<br>Hive三种元数据存储方式：<br>1&gt;.本地derby存储，只允许一个用户连接Hive，适用于测试环境<br>2&gt;.本地/远程MySQL存储，支持多用户连接Hive，适用于生产环境</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="mysql配置">mysql配置</h2><p>先前的服务器mysql有一些莫名地故障，于是准备重装。贸然重装肯定是一件愚蠢的事，首先要做的是把原有的mysql卸载干净。但如果你的mysql能正常地工作，那当我没提起这件事。卸载遵循以下步骤：</p>
<pre><]]>
    </summary>
    
      <category term="hive" scheme="http://kzx1025.github.io/tags/hive/"/>
    
      <category term="mysql" scheme="http://kzx1025.github.io/tags/mysql/"/>
    
      <category term="配环境" scheme="http://kzx1025.github.io/tags/%E9%85%8D%E7%8E%AF%E5%A2%83/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[什么样的Stephen Chow]]></title>
    <link href="http://kzx1025.github.io/2016/11/11/stephen-chow/"/>
    <id>http://kzx1025.github.io/2016/11/11/stephen-chow/</id>
    <published>2016-11-11T14:20:00.000Z</published>
    <updated>2016-11-24T13:55:38.000Z</updated>
    <content type="html"><![CDATA[<p>我一直认为,在我进入大学后出现了两位我人生中的精神导师,这个词意义说起来挺重大的,但我的确是认真<br>的说出了这句话.他们一位是作家,一位是演员.他们的名字叫做王小波和周星驰.<br>//待更新,看心情</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>我一直认为,在我进入大学后出现了两位我人生中的精神导师,这个词意义说起来挺重大的,但我的确是认真<br>的说出了这句话.他们一位是作家,一位是演员.他们的名字叫做王小波和周星驰.<br>//待更新,看心情</p>
]]>
    </summary>
    
      <category term="周星驰" scheme="http://kzx1025.github.io/tags/%E5%91%A8%E6%98%9F%E9%A9%B0/"/>
    
      <category term="扯淡学" scheme="http://kzx1025.github.io/tags/%E6%89%AF%E6%B7%A1%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[在大菠萝中遇到的一些小问题]]></title>
    <link href="http://kzx1025.github.io/2016/10/10/diablo/"/>
    <id>http://kzx1025.github.io/2016/10/10/diablo/</id>
    <published>2016-10-10T07:20:00.000Z</published>
    <updated>2016-11-22T09:17:25.000Z</updated>
    <content type="html"><![CDATA[<h2 id="大菠萝的任务">大菠萝的任务</h2><p>大菠萝全名diablo technology,是一家硬件技术外企.但是我是一名纯软界的小小码农,怎么会帮一个硬件公司做事呢.起初是这家公司中国区的技术人员跟我们组里的陆博大大比较熟,他们想招一两个懂Spark的人帮他们做一些测试和性能上的优化来得出他们研发的新硬件M1相比于市场上普通内存的特性与性能差异.于是陆博建议我担任这份兼职,工作不多而且还可以增一份不错的收入,众所周知,这种事情我是无法拒绝的.</p>
<p>为了推广M1,他们需要在M1上运行很多工业市场上流行的吃内存的软件与平台,包括spark,mysql,redis等.所以这三个月我就没事帮他们写一点测试的代码,优化spark的配置,寻找运行错误的bug,搭建redis-cluster这种活.期间爬过很多坑,有几个瞬间我感觉到自己是技术顾问,让我小小地膨胀一下.</p>
<h2 id="C程序的测试">C程序的测试</h2><p>C语言我是有好几年没碰了,作为一个大四以后一直在jvm语言中游走,有时用python写点小项目的人,几乎对指针这种东西处于懵逼模式.</p>
<p>代码的编写和测试流程我就不详细说了,说说遇到的段错误解决方案.也是这次跑C程序让我有了了解这方面知识的契机.发生了段错误/core dump,总结一下原因,一般是这几个:</p>
<ul>
<li>访问了不存在的内存地址</li>
<li>访问了系统保护的内存地址</li>
<li>访问了只读的内存地址等等情况</li>
</ul>
<p><strong>先用gdb -g -o xx xx.c 生成gdb可调试的文件。</strong>说到gdb调试,大概要知道这几个命令:</p>
<ol>
<li><p>gdb xx 进入gdb调试界面</p>
</li>
<li><p>b 行数 在第多少行打断点</p>
</li>
<li><p>按r进入运行状态</p>
</li>
<li><p>n是单步调试</p>
</li>
<li><p>s进入函数中调试</p>
</li>
<li><p>q是退出</p>
</li>
</ol>
<p>继续说解决core dump的bug, 然后运行程序, ./xx发生段错误后会生成core文件.接着运行命令<strong>gdb xx core.36129</strong>.输入where 会打印出具体的core dump发生在代码中哪个位置，方便定位bug。</p>
<p>还有一个bug是,每次都在内存地址被free的时候报无效指针,这种情况一般包含以下几个原因:</p>
<ol>
<li><p>一个地址被free了两次, 当然这个很容易查出来.</p>
</li>
<li><p>free的地址已经不是当时申请内存的起始地址了,注意可能在程序中的一些函数中对其做了一些操作.</p>
</li>
</ol>
<h2 id="Spark-Sql测试框架中踩得坑">Spark-Sql测试框架中踩得坑</h2><p>大菠萝公司的喵叽(算我们的上司大人)想在机器上测试Spark Sql在M1上跑的性能，让我调研下Spark-sql-perf这个已有的测试框架<a href="https://github.com/databricks/spark-sql-perf" target="_blank" rel="external">(项目地址)</a>。看了一下框架代码，差不多就是写了很多sql语句封装成一个个benchmark对象然后有一个多线程模式，然后一起开测。首先，在大菠萝的机器上部署测试框架，然后写一个简单的测试程序。代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">object SqlTest extends Serializable&#123;</span><br><span class="line">  <span class="function">def <span class="title">main</span><span class="params">(args: Array[String])</span>: Unit </span>= &#123;</span><br><span class="line">    val sparkConf  = <span class="keyword">new</span> SparkConf().setAppName(<span class="string">"test"</span>)</span><br><span class="line">    .setMaster(<span class="string">"local"</span>)</span><br><span class="line">    val sc = <span class="keyword">new</span> SparkContext(sparkConf)</span><br><span class="line">    val sqlContext = <span class="keyword">new</span> org.apache.spark.sql.SQLContext(sc)</span><br><span class="line">   val tables = <span class="keyword">new</span> Tables(sqlContext, <span class="string">"/Users/iceke/projects/tpcds-kit/tools"</span>, </span><br><span class="line">   Integer.parseInt(<span class="string">"1"</span>))</span><br><span class="line">    tables.genData(<span class="string">"data"</span>,<span class="string">"parquet"</span>,<span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>)</span><br><span class="line">    val tableNames = Array(<span class="string">"call_center"</span>, <span class="string">"catalog_page"</span>,  <span class="string">"catalog_returns"</span>, <span class="string">"catalog_sales"</span>,</span><br><span class="line">      <span class="string">"customer"</span>, <span class="string">"customer_address"</span>,  <span class="string">"customer_demographics"</span>, <span class="string">"date_dim"</span>,</span><br><span class="line">      <span class="string">"household_demographics"</span>, <span class="string">"income_band"</span>,   <span class="string">"inventory"</span>, <span class="string">"item"</span>, <span class="string">"promotion"</span>,</span><br><span class="line">      <span class="string">"reason"</span>, <span class="string">"ship_mode"</span>,  <span class="string">"store"</span>, <span class="string">"store_returns"</span>,  <span class="string">"store_sales"</span>, <span class="string">"time_dim"</span>,</span><br><span class="line">      <span class="string">"warehouse"</span>, <span class="string">"web_page"</span>,   <span class="string">"web_returns"</span>, <span class="string">"web_sales"</span>, <span class="string">"web_site"</span>)</span><br><span class="line">    <span class="keyword">for</span>(i &lt;- <span class="number">0</span> to tableNames.length - <span class="number">1</span>) &#123;</span><br><span class="line">      val a = sqlContext.read.parquet(<span class="string">"data"</span> + <span class="string">"/"</span> + tableNames&#123;i&#125;)</span><br><span class="line">     <span class="comment">// sc.broadcast(a)</span></span><br><span class="line">      a.registerTempTable(tableNames&#123;i&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    val tpcds = <span class="keyword">new</span> TPCDS (sqlContext = sqlContext)</span><br><span class="line">    val experiment = tpcds.runExperiment(tpcds.tpcds1_4Queries, iterations = <span class="number">1</span>,forkThread=<span class="keyword">false</span>)</span><br><span class="line">    experiment.waitForFinish(<span class="number">60</span>*<span class="number">60</span>*<span class="number">10</span>)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>先生成数据，大概几十张表。然后加载这几十张表，进行benchmark实验。本来过程很简单，但是需求是无止境的，喵叽说试试把所有的表cache到内存中，这样进行查询时快一点，听上去非常简单，在注册后加上一行cache表的代码就可以了。部分代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> val a = sqlContext.read.parquet(<span class="string">"data"</span> + <span class="string">"/"</span> + tableNames&#123;i&#125;)</span><br><span class="line"><span class="comment">// sc.broadcast(a)</span></span><br><span class="line"> a.registerTempTable(tableNames&#123;i&#125;)</span><br><span class="line"> sqlContext.cacheTable(tableNames&#123;i&#125;)</span><br></pre></td></tr></table></figure></p>
<p>我在mac上用local模式测了一下ok便提交给喵叽。</p>
<p>事情永远不会像想象的那么顺利，喵叽在集群上一测，就通过了几个benchmark，然后大量的stage报错，全部都是failed to get broadcast(TorrentBroadcast)异常，然后stage 直接失败，查看executor的日志发现已经有的broacast被remove了，但是接下来的加个task又会去获取这些broadcast，便会直接失败。这明显是不符合逻辑的，明明cache了所有表，靠异常堆栈信息并不好定位到错误的地方。我看了spark主页发现storage页面cache的RDD过一段时间就会消失，这也是一个重要的线索。</p>
<p>测试了半天还是出错，我开始静下心慢慢跟着框架的代码走，我发现最后每一个线程都会执行一个doBenchmark方法，<br>方法里面最后执行完查询操作之后会做一些善后处理。相关代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> def <span class="title">benchmark</span><span class="params">(</span><br><span class="line">    includeBreakdown: Boolean,</span><br><span class="line">    description: String = <span class="string">""</span>,</span><br><span class="line">    messages: ArrayBuffer[String],</span><br><span class="line">    timeout: Long,</span><br><span class="line">    forkThread: Boolean = <span class="keyword">true</span>)</span>: BenchmarkResult </span>= &#123;</span><br><span class="line">  logger.info(s<span class="string">"$this: benchmark"</span>)</span><br><span class="line">  sparkContext.setJobDescription(s<span class="string">"Execution: $name, $description"</span>)</span><br><span class="line">  beforeBenchmark()</span><br><span class="line">  val result = <span class="keyword">if</span> (forkThread) &#123;</span><br><span class="line">    runBenchmarkForked(includeBreakdown, description, messages, timeout)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    doBenchmark(includeBreakdown, description, messages)</span><br><span class="line">  &#125;</span><br><span class="line">  println(<span class="string">"!!!!!!!!!!!!!!!!after Bench"</span>)</span><br><span class="line">  afterBenchmark(sqlContext.sparkContext)</span><br><span class="line">  result</span><br></pre></td></tr></table></figure></p>
<p>这个善后处理是afterBenchmark方法，方法代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> def <span class="title">afterBenchmark</span><span class="params">(sc: SparkContext)</span>: Unit </span>= &#123;</span><br><span class="line">  <span class="comment">// Best-effort clean up of weakly referenced RDDs, shuffles, and broadcasts</span></span><br><span class="line">  System.gc()</span><br><span class="line">  <span class="comment">// Remove any leftover blocks that still exist</span></span><br><span class="line">  sc.getExecutorStorageStatus</span><br><span class="line">      .flatMap &#123; status =&gt; status.blocks.map &#123; <span class="keyword">case</span> (bid, _) =&gt; bid &#125; &#125;</span><br><span class="line">      .foreach &#123; bid =&gt; SparkEnv.get.blockManager.master.removeBlock(bid) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>它会对每个相关block的id进行移除，无论它是否做了cache。所以解决方法是注释掉afterBenchmark方法，与上次堆外内存的bug一样，发现bug的过程是痛苦的，解决方案是简单到发指的,让人痛苦,又让人快乐.</p>
<p>所以说，别人的框架不是万能的，虽然你操作起来更便捷，但你必须遵守它制定的那一些规则，有些规则是操蛋的，当你使用它时，如果一直被操蛋的bug所围困，就需要看看它的源码看看是否有问题，或者与你的策略存在偶然性的冲突。</p>
<p><strong>最后, 我的梦想是成为规则的制定者.</strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="大菠萝的任务">大菠萝的任务</h2><p>大菠萝全名diablo technology,是一家硬件技术外企.但是我是一名纯软界的小小码农,怎么会帮一个硬件公司做事呢.起初是这家公司中国区的技术人员跟我们组里的陆博大大比较熟,他们想招一两个懂Spark的人帮他们做]]>
    </summary>
    
      <category term="C语言" scheme="http://kzx1025.github.io/tags/C%E8%AF%AD%E8%A8%80/"/>
    
      <category term="bug" scheme="http://kzx1025.github.io/tags/bug/"/>
    
      <category term="内存" scheme="http://kzx1025.github.io/tags/%E5%86%85%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[修改Spark内核(Deca)所产生的两个奇怪bug]]></title>
    <link href="http://kzx1025.github.io/2016/09/28/spark-bug/"/>
    <id>http://kzx1025.github.io/2016/09/28/spark-bug/</id>
    <published>2016-09-28T07:39:47.000Z</published>
    <updated>2016-11-25T02:48:29.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Spark将数据放在jvm堆外导致无故卡死">Spark将数据放在jvm堆外导致无故卡死</h2><h3 id="思路实现与问题产生">思路实现与问题产生</h3><p>咱们内存计算小组陆博的文章Deca经过一年的努力终于中了vldb,作为其中参与了一些微小的工作的男人,虽然对其中一部分细节不是太清楚,因为这个Deca系统的开发涉及到将近5个人,我的工作囊括一下就是: </p>
<pre><code><span class="number">1.</span>完成了其中UDF的转换,将方法的操作转为对字节数组的操作;
<span class="number">2.</span>手写了Deca的手动版的代码,就是利用Deca的思想对Spark应用的代码进行改造;
<span class="number">3.</span>进行了大量的测试并统计GC时间,stage时间等相关数据.
</code></pre><p>其实Deca系统的核心思想就是将原有的java大对象转化为字节数组有序地放置在jvm中,这样一可以减少对内存的使用,<br>也可以基本避免所有的GC.附上论文<a href="https://arxiv.org/pdf/1602.01959v3.pdf" target="_blank" rel="external">Deca论文地址</a></p>
<p>老板的top中了之后,当然会将它扩展扩展然后投期刊,这是基本套路.要求扩展30%,其中就包括将之前的手动版的数据放置在堆外,还是以字节数组的形式来和堆内版本进行比较,理论上来说堆外版本肯定性能是比堆内好的,毕竟放置在堆外可以完全逃避GC的控制,也更加符合Deca的思想.</p>
<p>代码实现并不难,基本由Unsafe这个类操作完成.大概思路就是将Spark应用中需要缓存的RDD其中的partition的对象用字节数组的形式写在堆外,读的时候再直接按照偏移量读取,贴上部<br>分代码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UnsafePR._</span><br><span class="line"><span class="keyword">private</span> val baseAddress = UNSAFE.allocateMemory(size)</span><br><span class="line"><span class="keyword">private</span> var curAddress = baseAddress</span><br><span class="line">def address = baseAddress</span><br><span class="line">def free:Unit=&#123;</span><br><span class="line">  UNSAFE.freeMemory(baseAddress)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">def <span class="title">writeInt</span><span class="params">(num:Int)</span>:Unit</span>=&#123;</span><br><span class="line">  UNSAFE.putInt(curAddress,num)</span><br><span class="line">  curAddress += <span class="number">4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><a href="https://github.com/zx247549135/DecaApplication/blob/master/src/main/scala-2.10/decaApp/UnsafePR.scala" target="_blank" rel="external">完整的Deca手动版PageRank代码地址</a></p>
<p>起先在本机的local模式测试了堆外版LR和PageRank应用当然是没问题的,结果也是正确的.然后转移到服务器集群上进行测试.令人惊喜的是,一个神奇的bug出现了.</p>
<h3 id="Bug的特征">Bug的特征</h3><p>此Bug是本人coding以来见识到的算的上奇怪的一个bug了,它有以下几个特征.首先LR的堆外版本集群测试是没有问题的,但是切换到PageRank的堆外版本来测试时,总是在ZipPartition这个stage最后几个task执行的时候jvm crash掉,这个job就直接卡死了,必须手动杀掉才能停止.executor异常日志:<br><img src="/img/1.jpg" alt="executor异常日志"></p>
<p>stage卡住图示:<br><img src="/img/2.jpg" alt="stage卡住"></p>
<p>而且还有一个特殊的症状:就是PR跑2G数据量的时候居然不会挂掉,一到7G和20G的时候就会挂掉.而且local模式不会出错,一个executor也不会出错,一旦增加到多个executor就会出错.</p>
<h3 id="Bug原因分析与结论">Bug原因分析与结论</h3><p>一开始想到的原因是shuffle的问题,因为local和单个executor不会出错,一旦涉及到网络传输就会报错.我怀疑是不是序列化方式的问题,分别用kryo和java自带的序列化方式测试了一下,然而都会报错.后来想了想应该不是网络传输的问题,不然小数据量怎么可以通过.我上网查了一下jvm crash那段报错信息,基本都是由于Unsafe访问到非法位置的原因,于是开始往这个方向考虑.</p>
<p>最后与师兄讨论中意识到问题的关键所在,首先Spark一个executor执行task比较慢时,如果另一个executor执行完一个stage的所有task时,会将剩余的task调度到那个节点去执行,也就是non-local task.non-local task是从网络传输过去的,这部分task是由cache RDD的partition生成而来的,这部分task是从block manager过去的,然而partition中的UnsafeEdge对象中只有一个Unsafe成员变量,一个初始地址和终点地址,和分配在jvm堆内的对象不同,并不携带真正的数据.所以这个task被调度到其他executor时,自然会非法访问堆外内存,然后jvm crash掉,这也可以解释为什么stage中位置为Any的task都不能成功执行这个现象.至于2G的数据量为什么可以通过,因为task运行的时间很短,几乎不需要调度就可以在一个executor中全部完成.</p>
<p>所以解决方案就是尽量不让task调度到其他的executor上执行,可以尽量增大spark.locality.wait这个变量来避免出错.</p>
<h2 id="硕大的cache数据">硕大的cache数据</h2><pre><code>这个就简洁地介绍一下了,这是我大概<span class="number">11</span>月<span class="number">10</span>号遇见的
</code></pre><h3 id="背景">背景</h3><p>关于shuffle的VST拆解部分需要加到论文修改中,不过在意外中我发现了之前Deca release1.0版本的一个bug.那就是由于Deca将cache数据的对象完全转化为字节数组存储在jvm中,但是吊诡的现象在于Deca cache的数据居然比原生Spark的还大,这明显是不合理的.初看了一下代码发现是没有问题的.于是联系已经毕业的裴师兄,他说他之前就遇到这个问题了,只不过一直没改.这应该就是传说中的前人挖坑,后人填坑.但我同时也是很兴奋的,因为我们之前手动版本的实验结果很合理,改动Spark内核的自动版本也是同样地思路和流程,但是却出现了这种奇怪的现象,你知道解决bug是一个很能产生成就感的一个举措.在SparkContext将cache的RDD的迭代器做了一次调整,生成一个新的RDD并cache,然后将原本cache的RDD释放掉,重新调整一下RDD链,这样缓存的RDD将会被我们生成的RDD替换掉.之前对缓存的RDD所做的操作是:将里面返回KV对的迭代器改写一下,变换成往一个字节数组缓冲区写字节数组(按顺序写),然后返回新的迭代器.</p>
<h3 id="修复">修复</h3><p>后来发现之前返回的迭代器基本单位还是一个个KV对,这样就算是按字节数组写了也还是和Spark Cache的数据占用着差不多的大小,于是很简单啦,这里我将一块字节数组区称为CacheChunk,事实上它的类名也是这个.生成CacheChunk后,用Iterator包装一下便返回.跑了一下local模式,结果可想而知,抛出血红色的异常,我用的Idea,不知道其他的编辑器是不是这样.众所周知,Spark的每一个stage的结束要么是ShuffleTask,要么是ResultTask.ShuffleTask需要落磁盘,往block写点什么,这时候出发真正的RDD计算,就是调用RDD的迭代器.当然这里有个判断,如果某个RDD被定义了persist,第一次计算时会将它的计算结果常驻在内存中再返回迭代器,这样下一个stage用到此RDD时便直接在内存中获取,无需计算.管理这个流程的是一个叫CacheManager的哥们,我们之前返回的迭代器是一个iterator,iterator里包含着CacheChunk,CacheChunk里面又有一个迭代器方法,所以CacheManager肯定识别不了了呗.方便,给这个变换的CacheRDD加一个标签变量,切勿不要给它trasient这个标识,它需要被序列化.如果是Deca的RDD便让CacheManager多一个步骤,获取迭代器之后,强制转换为CacheChunk,再取一次迭代器,这样就能获取真正的数据.好,测试通过,perfect.自信地放到集群中去测试,令人”欣慰”的是,cache的数据反而更巨大!</p>
<p>后来怎么办呢,研究CacheManager下面的代码,继续调试往里面跟着走,我只想感叹一句,真的很深…就连一个普通的HashMap Spark都会根据自己的需求改.最后发现RDD的大小的评估是一个SizeEstimator的类实现的,部分功能代码如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> def <span class="title">visitSingleObject</span><span class="params">(obj: AnyRef, state: SearchState)</span> </span>&#123;</span><br><span class="line">  val cls = obj.<span class="function">getClass</span><br><span class="line">  <span class="title">if</span> <span class="params">(cls.isArray)</span> </span>&#123;</span><br><span class="line">    visitArray(obj, cls, state)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj.isInstanceOf[ClassLoader] || obj.isInstanceOf[Class[_]]) &#123;</span><br><span class="line">    <span class="comment">// Hadoop JobConfs created in the interpreter have a ClassLoader, which greatly confuses</span></span><br><span class="line">    <span class="comment">// the size estimator since it references the whole REPL. Do nothing in this case. In</span></span><br><span class="line">    <span class="comment">// general all ClassLoaders and Classes will be shared between objects anyway.</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    val classInfo = getClassInfo(cls)</span><br><span class="line">    state.size += alignSize(classInfo.shellSize)</span><br><span class="line">    <span class="keyword">for</span> (field &lt;- classInfo.pointerFields) &#123;</span><br><span class="line">      state.enqueue(field.get(obj))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大概思路就是判断对象类型,原生类型直接算,数组就累加算.如果不是原生类型,继续将里面的成员变量入栈,递归调用此函数.当我调试到这儿看调试信息的时候,发现一共访问了有一千多个成员变量,明显不合理.后来发现,CacheChunk里有个Spark定制的IterupptedIterator,这里面带出一批Spark相关的变量,导致评估大小大了整整十几倍.可是CacheChunk是可以不需要这个iterator的,于是将它换了个地方.重新测试,终于okay.流下了喜悦的眼泪,想高歌一曲,想起在实验室便作罢.</p>
<p>之后还遇到CacheChunk自动扩增容量的问题,不过解决起来比较简单,就不在此描述.</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Spark将数据放在jvm堆外导致无故卡死">Spark将数据放在jvm堆外导致无故卡死</h2><h3 id="思路实现与问题产生">思路实现与问题产生</h3><p>咱们内存计算小组陆博的文章Deca经过一年的努力终于中了vldb,作为其中参与了一些微小的工作]]>
    </summary>
    
      <category term="bug" scheme="http://kzx1025.github.io/tags/bug/"/>
    
      <category term="spark" scheme="http://kzx1025.github.io/tags/spark/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[论思想同化的艺术]]></title>
    <link href="http://kzx1025.github.io/2016/09/11/assimilation/"/>
    <id>http://kzx1025.github.io/2016/09/11/assimilation/</id>
    <published>2016-09-11T12:20:00.000Z</published>
    <updated>2016-11-24T18:24:43.000Z</updated>
    <content type="html"><![CDATA[<div style="width:50%;"><br><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="http://music.163.com/outchain/player?type=2&id=29283291&auto=1&height=66"></iframe><br></div>


<p>看过一段访谈,一个摇滚乐队主唱的访谈,这个人叫邓斐,乐队名字叫寂寞.夏.日.曾经有一段时间疯狂地听他们的歌.他谈到他们的歌《这个易同化的民族》时说道:</p>
<pre><code><span class="string">"我们正在被对权力的卑躬屈膝同化,正在被对文化和艺术弱智的认知同化,我们拿来从不消化甚至不知何物就充当自己,</span>
 我们做事不认真不努力随后从不自我反省反而学会相互制约和压制欺骗,我们正在被机会主义同化从无察觉...<span class="string">"</span>
</code></pre><p>他想批判的很多,在其歌词中也可见一斑,他在我眼中算得上摇滚界的当代杜甫.这里要说到摇滚是什么,窦唯曾经说过:对于摇滚没有必要给它做个定义,它一定是有感而发的,自由的,自然的,不拘一格的。摇滚可以不批判,但如果完全屈服于市场,那它就是商品,有确定的价格,而没有其内在可挖掘的价值.有点岔开话题,这段访谈的我不全认同,毕竟我不是机器,再说机器也有一个处理单元,会将输入的东西进行转化一下或稍作处理进行输出,哪怕一个简单的函数也是这样.</p>
<p>互联网大潮将人们的言论冲散在各个地方,随处可见.其中我们不妨将一个观点看做一个岛屿,你只看到有的岛屿上人多,有的人少.有的人们会跟随某个具有代表性的人去向某个岛,也有的会搭着小船一下到这个岛,一下空降到另一个岛.这种情景我是不希望看到的,作为一个人,一个个体,他有自己的处理单元,他应该做到可以独立思考,而不是跟随着舆论的大潮漂来漂去,你应该在某个合理的范围内坚守自己的观点,将这个岛屿看做你的一个暂时家园,请不要轻易放弃它.</p>
<p>哦对了,观点的表达来自话语,话语不能表达一个观点的全部.</p>
]]></content>
    <summary type="html">
    <![CDATA[<div style="width:50%;"><br><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="http://music.1]]>
    </summary>
    
      <category term="扯淡学" scheme="http://kzx1025.github.io/tags/%E6%89%AF%E6%B7%A1%E5%AD%A6/"/>
    
      <category term="摇滚" scheme="http://kzx1025.github.io/tags/%E6%91%87%E6%BB%9A/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[借天池中间件复赛谈NIO]]></title>
    <link href="http://kzx1025.github.io/2016/08/15/tianchi-nio/"/>
    <id>http://kzx1025.github.io/2016/08/15/tianchi-nio/</id>
    <published>2016-08-15T12:20:00.000Z</published>
    <updated>2016-11-30T09:01:02.000Z</updated>
    <content type="html"><![CDATA[<h2 id="比赛的简单总结">比赛的简单总结</h2><p>参加天池是被裴师兄安利的,这个很重要.在我眼中,裴博代码一直是写得飞起的那种,就是一边用B站放着billboard榜单,一边在那啪啪啪敲着代码,这看起来绝对很酷.所以我内心是崇拜他的,至少在技术上,他很刻苦,表现在很多方面.在此不一一赘述,因为我并不想在这开表彰会.他告诉我参加这个比赛会收获很多,我当然无条件相信,他当时参加的是机器学习相关的比赛.上半年正好有一场预测音乐播放量的比赛,我便屁颠颠地参加,对机器学习一窍不通,于是便慢慢学,特征,建立模型,训练.耗时一个半月,纯模型效果并不好,于是加了一些规则,后来还用了股票里经常遇到的时序模型,嗯,挺高大上的.这个比赛的确学习了很多,但总感觉浮于表面,略显浮夸,写代码也不是很多,更多的参赛选手都是搞机器学习和数学统计的,我并不在行.</p>
<p>这时候一个新比赛来华科路演,跑过去听了一听,意料之中,没什么太大收获,但是这个比赛引起了我极大的兴趣.首先它涉及系统设计,代码量跟机器学习类的比赛肯定不是一个级别,初赛和复赛考察内容很不一样.我觉得这种比赛还是很有趣的,但可能比较累,因为代码一多,因此而诞生的bug也会多起来,这点不太像机器学习的比赛,大部分时间是在等待和思考策略,动手的时间并不多.</p>
<p>中间件比赛分为初赛和复赛.初赛是实现一个实时统计双十一交易数据的系统,用到了三个组件jstorm,rocketmq和tair.都是阿里自家的产品,但都可以在原先的开源平台中找到原型,分别是storm,rabbitmq和redis.用法和api也大同小异,这个题目考察的主要还是熟悉这三个系统的使用,基本程序能正常运行跑出结果就能进前100了,如果想要跑到更好的成绩就需要想到更好的缓存策略.但你又不能把所有数据常驻内存,这样程序就会挂掉,而且这也不符合流计算的思想,流计算就应该是将数据想象成一段水流(不免让人想起破坏之王里的断水流大师兄),只不过水流会途径一些地方经过加工,如果水流囤积,那必然引起溃堤等风险.我的基本策略是jstorm的bolt主线程处理数据并统计,再开一个独立的线程用于数据的同步然后发送到下一个bolt.对我来说jstorm和storm最不同的一点就是:jstorm的Spout nextTuple和ack/fail运行在不同线程,这样可以防止CPU空转.storm的bolt和spout组件构成一个topology,一个设计优雅的拓扑图也是可以大大提高程序性能的.</p>
<p>关于复赛,设计一个订单查询系统,不在现有的开源平台上写应用,而是纯用java标准库,这个代码量可想而知.但后来赛方说可以用一些简单的轮子,比如基于磁盘的map,或者B+树什么的,纯用别人的开源数据库肯定是不行的.但比赛核心并不是这个,如果是这样功能大家都可以做出来,最重要的还是策略和优化.起先在github上找基于磁盘的B+树轮子,找了半天找到一个外国小伙写得轮子,很简洁.拿来一用,发现一个bug还有些许缺陷,后来还提交了commit给他,他也很客气merge了,不小的成就感,不得不说.</p>
<p>简单说一下程序策略:</p>
<ul>
<li>构造：采用多线程分别对各个订单文件建立索引，索引内容为记录在文中的偏移量和该记录长度的结合体,起初先合并所有的订单文件再建立索引，后来发现合并与否对查询速度没有太大影响，由于没有进行多次测试，这个结论可能不成立。建立索引的方式起初是一部分B+树，一部分采用基于磁盘的map，后期由于B+树建立索引较慢，经常一小时内不能建完，后期全部改为基于disk的map。比赛后期性能改进包括将卖家和商品信息的索引全部放置在内存中，因为这两部分信息的索引大小之和并不大；将卖家与商品信息出现的字段缓存起来，若后期查询中字段不在其中，则省略了部分查询的步骤。</li>
<li>查询：针对每个索引上层封装为一个DB，其中包含多个table对象，对应各个小索引文件。在构造索引期间对每个原记录文件和索引文件分别映射为一个MappedByteBuffer对象，有的记录长度大于int最大值，对这种文件进行分段映射多个mappedbytebuffer对象，具体查询请求时，在bytebuffer中读取信息。查询支持完全并发，但是由于每个索引文件都对应了一个table所以查询时需要遍历所有table最后返回结果，这种策略较为愚蠢。</li>
</ul>
<h2 id="关于NIO">关于NIO</h2><p>这次比赛算是很好的一次理解和使用NIO的机会,借这次简单一下介绍下这方面.<br>//未完待续</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="比赛的简单总结">比赛的简单总结</h2><p>参加天池是被裴师兄安利的,这个很重要.在我眼中,裴博代码一直是写得飞起的那种,就是一边用B站放着billboard榜单,一边在那啪啪啪敲着代码,这看起来绝对很酷.所以我内心是崇拜他的,至少在技术上,他很刻苦,表现在很]]>
    </summary>
    
      <category term="NIO" scheme="http://kzx1025.github.io/tags/NIO/"/>
    
      <category term="java" scheme="http://kzx1025.github.io/tags/java/"/>
    
      <category term="天池" scheme="http://kzx1025.github.io/tags/%E5%A4%A9%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Some Pictures]]></title>
    <link href="http://kzx1025.github.io/2015/10/14/Some-Pictures/"/>
    <id>http://kzx1025.github.io/2015/10/14/Some-Pictures/</id>
    <published>2015-10-14T15:52:17.000Z</published>
    <updated>2015-10-14T15:53:17.000Z</updated>
    <content type="html"></content>
    <summary type="html">
    
    </summary>
    
      <category term="photo" scheme="http://kzx1025.github.io/tags/photo/"/>
    
  </entry>
  
</feed>
